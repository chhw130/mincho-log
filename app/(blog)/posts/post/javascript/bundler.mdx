---
title: bundler에 대해 알아보자.
date: 2025-02-03
description: 지난 시간에는 JavaScript의 모듈 시스템의 발전에 대해 알아 보았다. 이번에는 JavaScript bundler에 대해서 한번 알아보자.
category: JavaScript
thumbnail: /images/post/javascript/bundler/module-system.webp
---

<Callout>
지난 시간에는 JavaScript의 모듈 시스템의 발전에 대해 알아 보았다.
이번에는 JavaScript bundler에 대해서 한번 알아보자.
</Callout>

# 모듈 시스템에서의 한계
모듈을 나누어 관리하는 건 개발환경에 큰 도움을 가져다 주었지만 따라 오는 트레이드 오프는 없을까?
분명히 존재한다. 

모듈을 나누다 보니 Js파일을 브라우저에서 가져올 때 그만큼 네트워크 요청을 하게 된다. 네트워크 요청 비용도 비용이지만, 파일 하나라도 제대로 받지 못하면 문제가 발생할 수 있다.
이러한 문제들은 당연히 사용자가 겪어야하는 불상사가 생긴다. 요즘과 같이 거대한 애플리케이션을 만들 수록 부담은 고스란히 사용자에게 축적이 되어 갈 수 밖에 없는 구조이다.

게다가 `esmodule`이 표준으로 자리잡기 전까지는 모듈 시스템에 표준이 없었다. 당시 CommonJS와 AMD방식 제 각각 이였다.

그래서 `webpack`이 등장하게 되었다.

# What is Webpack?

이미지

webpack은 2012년 Tobias [Koppers(토비아스 코퍼스)](https://github.com/sokra)가 개발하였다. 여러 모듈들을 하나의 파일로 번들링 시켜서 앞서 설명했던 문제들을 해결한 것이다. 단순히 하나의 파일로 번들링한 것말고도 여러 장점들이 존재한다.


## 여러 모듈 방식 호환
당시 webpack이 처음 등장했을 때, CommonJS(require)와 AMD(define)을 ES5 코드로 변환하여 브라우저에서 실행 가능하도록 일관성을 유지했다. 그래서 사실상 web개발의 표준처럼 자리잡았다.

그리고 2015년 `esmodule`이 등장했을 때도 webpack은 이를 호환시키기 위해서 노력했다. 하지만 큰 어려움이 존재했었는데..
- esmodule이 등장했을 당시 초창기라 브라우저와 완벽지원이 되지 않음.
- JavaScript생태계에서 아직까지 CommonJS와 AMD를 많이 사용하고 있어서 이를 esbuild와 호환시켜야 하고 걷어낼 수도 없었음.

webpack측에서는 webpack2가 나와서야 esmodule을 완벽 호환하기 시작했다. https://webpack.kr/api/module-methods/

## Tree Shaking 및 최적화
<Callout>
Tree shaking은 사용되지 않는 코드를 제거하기 위해 JavaScript 컨텍스트에서 일반적으로 사용되는 용어입니다.
</Callout>
webpack을 사용해야하는 이유 중 하나는 트리셰이킹 기능이다. 사용하지 않는 코드를 정리해준다.

이는 webpack공식 페이지에서 예제 코드와 함께 잘 정리 되어 있으므로, 함께 살펴보자.
https://webpack.kr/guides/tree-shaking/

```css
webpack-demo
|- package.json
|- package-lock.json
|- webpack.config.js
|- /dist
  |- bundle.js
  |- index.html
|- /src
  |- index.js
+ |- math.js
|- /node_modules
```

현재 디렉토리 구조는 이와 같고 유틸리티 파일 `math.js`가 추가되었다.

```javascript
// math.js
export function square(x) {
  return x * x;
}

export function cube(x) {
  return x * x * x;
}
```

`math.js`에서는 다음과 같은 유틸함수를 export하고 있다.

```javascript
// webpack.config.js
const path = require('path');

module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist'),
  },
  // development 모드 추가
 mode: 'development',
 optimization: {
   usedExports: true,
 },
};
```

mode옵션을 development로 설정합니다. development로 설정하게 되면 번들링 되더라도 Tree shaking이 되지 않습니다.

```javascript
// index.js
import { cube } from './math.js';

  function component() {
   const element = document.createElement('pre');

   element.innerHTML = [
     'Hello webpack!',
     '5 cubed is equal to ' + cube(5)
   ].join('\n\n');

    return element;
  }

  document.body.appendChild(component());
```
다음과 같이 index에서는 `cube`함수만을 import하고 있습니다. 이 때 번들링을 시도하면 어떻게 될까?

```javascript
// dist/bundle.js
/* 1 */
/***/ (function (module, __webpack_exports__, __webpack_require__) {
  'use strict';
  /* unused harmony export square */
  /* harmony export (immutable) */ __webpack_exports__['a'] = cube;
  function square(x) {
    return x * x;
  }

  function cube(x) {
    return x * x * x;
  }
});
```

` /* unused harmony export square */`로 주석처리가 되어 있지만 사용하지 않은 `square`함수는 번들링 파일에 포함되어 있다.

실제 프로덕션 모드에서는 번들링되어 `bundler.js`에 `square`함수는 제거된다.


## Webpack에서의 핵심 개념
웹팩의 장점을 알아봤는데, 기본적인 핵심 개념을 살펴보면 좋을 거 같아서 정리해보았다.

### Entry / Output
`entry`는 말그대로 진입점이라는 뜻이다. webpack 내부 디펜던시 그래프를 생성하기 위한 진입점이다.

```javascript
// webpack.config.js
const path = require('path');

module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist'),
  },
 mode: 'development',
 optimization: {
   usedExports: true,
 },
};
```
위에 살펴봤던 예제 코드에서 entry는 `./src/index.js`이다. 여기를 root로 놓고 import/export를 통한 의존성 그래프를 생성하는 것이다.
기본적으로 entry를 설정하지 않으면 `index.js`가 된다.

`output`은 이 번들을 어느 위치에 내보낼지 설정할 수 있다. 위에서는 file의 이름을 설정하고 path를 위치시킨 것을 확인할 수 있다.

### Loader
`loader`는 다양한 종류의 파일을 웹팩이 이해할 수 있도록 해준다. webpack은 기본적으로 JavaScript와 JSON파일만을 인식하기 때문에 loader를 사용해야 한다.
로더를 이용하면 이러한 규격 외 파일들을 모듈로 변환 처리하여 디펜던시 그래프에 추가한다.

```javascript
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,  // .css 파일에 대해
        use: ['style-loader', 'css-loader']  // 로더 적용
      }
    ]
  }
}
```

### Plugins
로더는 특정 유형의 모듈을 변환하는 데 사용되지만, 플러그인을 활용하여 번들을 최적화하거나, 애셋을 관리하고, 또 환경 변수 주입등과 같은 광범위한 작업을 수행 할 수 있다.

```javascript
const HtmlWebpackPlugin = require('html-webpack-plugin');
const webpack = require('webpack'); // 내장 plugin에 접근하는 데 사용

module.exports = {
  module: {
    rules: [{ test: /\.txt$/, use: 'raw-loader' }],
  },
  plugins: [new HtmlWebpackPlugin({ template: './src/index.html' })],
};
```

### Mode
애플케이션 모드를 선택할 수 있습니다.

(이미지)

## webpack의 한계
webpack은 많은 장점을 가지고 있는 도구다. 그리고 오래전부터 호환성을 지키기위해 많은 발전이 있고 기능도 점차 증가하며, 이를 지원하는 plugin도 많다.

하지만 webpack의 가장 큰 단점이자 사내에서 계륵으로 여기지는 이유가 있었다. 그래서 번들링 속도가 느려 devServer를 시작하기 까지 꾀나 시간이 소요되었다.

이를 좀 더 잘 이해하기 위해서 webpack에서 devServer가 어떠한 방식을 거치는 지 알면 좋을 거 같아서 간단하게 과정을 정리했다.
1️. Webpack이 index.js를 기준으로 번들링 수행 (entry를 기준으로)
2️. 번들된 결과를 메모리에서 관리
3️. 개발 서버 실행(요청한 포트로 실행)
4️. 파일 변경 감지 → 변경된 파일만 재번들 & 자동 갱신 (HMR)

<Callout>
HMR이란?
Hot Module Replacement(HMR)는 모듈 전체를 다시 로드하지 않고 애플리케이션이 실행되는 동안 교환, 추가 또는 제거합니다. 다음과 같은 몇 가지 방법으로 개발 속도를 크게 높일 수 있다.
</Callout>

현재 사내에서는 vue-cli로 프로젝트가 진행중이였고, vue-cli는 바로 webpack기반이다. devServer를 시작하기 위해 번들링 시간만 무려 평균 30초이상이 소요되었다.

(이미지)

이렇게 느린 이유로는 webpack이 인터프리터 언어인 JavaScript로 만들어졌는 것이다. 또 다른 하나는 webpack이 기본적으로 `bundle based dev server`형식이다. 어떤 파일의 특정 부분을 수정하면 의존성을 포함한 모든 모듈을 다시 번들링 하는 과정이 필요하다.


# 그래서 마이그레이션 한 Vite
