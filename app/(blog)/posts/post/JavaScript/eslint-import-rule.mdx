---
title: import문에 규칙을 추가해보자
date: 2025-12-11
description: 프론트엔드 작업을 한다면 어김없이 마주하는 것 중 하나는 모듈 Import입니다. 사실 프론트엔드단 작업을 위해 현재 많이 사용하는 JS에서는 모듈 시스템이 존재하지 않았습니다. JS는 단순 스크립트 보조 언어로 탄생했기 때문입니다. 
category: JavaScript
thumbnail: /images/post/javascript/bundler/module-system.webp
---

프론트엔드 작업을 한다면 어김없이 마주하는 것 중 하나는 모듈 import다. 사실 프론트엔드단 작업을 위해 현재 많이 사용하는 JS에서는 모듈 시스템이 존재하지 않았다. JS는 단순 스크립트 보조 언어로 탄생했기 때문이다. CommonJS, AMD시스템 등 여러 모듈 구조의 역사가 진행되고 드디어 ES6에서 module이 표준화 되었다.


# module Import문을 관리해야 하는 이유
프로젝트를 진행할 때 가장 중요한 것은 무엇일까? 협업이 중요하지 않을까? 
그럼 개발자들 간에 협업을 하기 위해 코드레벨에서 지켜야 할 약속 중 가장 중요한 것은 무엇일까? 내가 생각한 키워드는 `일관성`이다.

하지만 현재 프로젝트는 컨벤션이 있다고 하더라도 실수로 놓치고 있는 부분이나 코드 리뷰에서 중요한 포인트를 체크하기 위해 일부러 넘어가는 케이스들이 간혹 존재 하였다. 그 중 사소했던 것 중 하나는 import문이였다.

## 가독성 측면
정해진 규칙에 따라 import문을 그룹 짓거나 분류하지 않으면, 협업하는 팀원뿐만아니라 본인조차 파일의 의존성 파악이 한눈에 들어오지 않는 경우들이 몇차례 존재한다.

### 정렬이 되지 않은 코드
```javascript
import App from './components/App';
import React from 'react';
import { debounce } from 'lodash';
import axios from 'axios';
```

### 정렬이 된 코드
```javascript
// 외부 패키지
import React from 'react';
import axios from 'axios';
import { debounce } from 'lodash';

// 내부 모듈
import App from './components/App';
```

### 일관성
module을 import시에 별칭(aliases)를 사용하면 상대 경로 대신, 절대 경로로 가져올 수 있다.
예시로 상대 경로로 가져오게 되면 `../../../../Component.vue`로 prefix가 매우 길어지며 다른 import문과의 일관성에서 차이를 보일 수 있다.
```javascript
// tsconfig
{
  "compilerOptions" : {
      "paths": {
      "@/*": [
        "src/*"
      ]
      //...생략
    },  
  }
}
```
그래서 다음과 같이 `compilerOptions`로 별칭을 붙여서 간단하게 경로를 지정하는 것이 좋다.


### 불필요한 commit diff방지
코드 리뷰시 많은 변경사항은 리뷰이에게 큰 불편함을 가져다 줄 수 있다. module import 구문은 사실 크게 리뷰할 만한 사항은 없긴하다. 하지만 코드의 양이 많아지는 것 자체가 안정감을 주기 어려울 수 있다.
어렵지 않고 간단한 코드라도 특정 한 파일에서 코드라인이 몇백줄이 된다면 그 것 자체로 벌써부터 피곤해지지 않는가..?

- dev branch
```javascript
import { ref } from 'vue'
import axios from 'axios'
import UserProfile from '@/components/UserProfile.vue'
import { formatDate } from '@/utils/dateUtils' 
```

- example branch(dev branch기반)
```javascript
// 단순히 줄 순서만 변경
import axios from 'axios'
import { ref } from 'vue'
import UserProfile from '@/components/UserProfile.vue'
import { formatDate } from '@/utils/dateUtils'
```

- merge pr to dev
```diff
- import { ref } from 'vue'
- import axios from 'axios'
+ import axios from 'axios'
+ import { ref } from 'vue'
  import UserProfile from '@/components/UserProfile.vue'
  import { formatDate } from '@/utils/dateUtils'
```

예제를 통해 규칙이 없는 import문으로 인해 코드 리뷰시 불필요한 Diff가 생기는 것을 확인할 수 있다.

# import-rule-order 적용하기
eslint설정에서 import rule을 추가할 수 있다. eslint에서 제공하는 기본적인 rule을 적용할 수도 있지만 `eslint-plugin-import` plugin을 사용해서 좀 더 다방면으로 기능을 적용가능하다. 

> [eslint공식 문서에서 나와 있는데, eslint측에서 이 plugin을 직접 지원하는 것 같다.](https://eslint.org/blog/2022/02/paying-contributors-sponsoring-projects/#supporting-the-community)

적용과정은 [공식문서](https://github.com/import-js/eslint-plugin-import/blob/main/docs/rules/order.md#groups)를 참고하여 서술과정을 아래에 풀어가려고 한다.

```cmd
yarn add -D eslint-plugin-import
```

```javascript
// .eslintrc.js
module.exports = {
  rules : {
    "import/order": [
      "error",
      {
        groups: [
          "builtin",
          "external",
          "internal", 
        ],
        pathGroups: [
          {
            pattern: "vue**", 
            group: "builtin",
            position: "before",
          },
          {
            pattern: "**/components/**",
            group: "internal",
            position: "after",
          },
        ],
        "newlines-between": "always", // 그룹 사이 줄바꿈 
        alphabetize: {
          order: "asc",             // 알파벳 오름차순 정렬
          caseInsensitive: true,    // 대소문자 구분 없이 정렬
        },
      },
    ]
  }
}
```
lint파일에 다음과 같이 설정한다.

## groups
import문을 그룹화하여 관리할 수 있다. 많은 옵션이 주어지지만 크게 `builtin, external, internal`로 구분한다.

```javascript
{
  "import/order": ["error", {
    "groups": [
      // Imports of builtins are first
      "builtin",
      // Then sibling and parent imports. They can be mingled together
      ["sibling", "parent"],
      // Then index file imports
      "index",
      // Then any arcane TypeScript imports
      "object",
      // Then the omitted imports: internal, external, type, unknown
    ],
  }],
}
```

- builtin
```javascript
// node "builtin" modules
import fs from 'fs';
import path from 'path';
```
기본적인 builtin 메서드들이 이 그룹에 속하게 된다.

- external
```javascript
// "external" modules
import _ from 'lodash';
import { ref } from 'vue';
```
외부 라이브러리를 기준으로 이 그룹에 속하게 된다.

- internal
```javascript
// "internal" modules
import foo from 'src/foo'
```
전반적인 프로젝트 내부 모듈이 이 그룹에 속하게 된다.

공식문서에 따르면 내부적으로 특정 규칙을 통해 그룹화 알고리즘이 진행된다고 한다.
위에는 프로젝트에서 적용하기 위해 간단한 그룹만을 설정했지만 실제로는 더 많은 그룹을 설정할 수 있다.
> "builtin" | "external" | "internal" | "unknown" | "parent" | "sibling" | "index" | "object" | "type"

```javascript
// 1. 할당되지 않은 import (side-effect를 위한 import)
import './styles.css';  // warnOnUnassignedImports가 비활성화된 경우 무시됨

// 2. TypeScript 특수 선언
import log = console.log;  // 'object' 그룹으로 분류

// 3. type-only import
import type { UserType } from './types';  // 'type' 그룹으로 분류

// 4. internal import (import/internal-regex 매칭)
import { internalUtil } from '@internal/utils';  // 'internal' 그룹

// 5. 절대 경로 import
import { something } from '/absolute/path';  // 'unknown' 그룹

// 6-7. Node.js 빌트인 모듈
import fs from 'fs';  // 'builtin' 그룹
import customCore from 'custom-core-module';  // import/core-modules에 정의된 경우 'builtin' 그룹

// 8. 부모 디렉토리 상대 경로
import { parent } from '../parent';  // 'parent' 그룹

// 9. 현재 파일/인덱스 import
import { current } from '.';  // 'index' 그룹
import { index } from './index';  // 'index' 그룹

// 10. 형제 디렉토리 상대 경로
import { sibling } from './sibling';  // 'sibling' 그룹

// 11-12. 외부 모듈 (node_modules 또는 패키지 루트 외부)
import express from 'express';  // 'external' 그룹
import outsidePackage from '../../../outside-package';  // 'external' 그룹

// 13. 내부 모듈 (패키지 루트 내부)
import { internal } from 'src/utils';  // 'internal' 그룹

// 14. 스코프가 있는 패키지
import { scoped } from '@types/node';  // 'external' 그룹

// 15. 일반적인 외부 패키지
import moment from 'moment';  // 'external' 그룹
```

개인적으로 너무 많은 그룹화를 진행하기 보다는 최소한의 그룹을 이용해서 정리하는 편이 좋은 것 같았다.
그룹화 규칙마저 빡세게 정해버리면, 정리를 위한 정리가 되어 오히려 더 복잡해지는 느낌이였다.


## pathGroups
그룹화하는 것은 간단하지만, 예외 사항이 존재할 수 있다. 특정 그룹에 속하는 파일을 다른 그룹에 넣고 싶다거나 제외시키고 싶을 수 있는데 `pathGroups` 프로퍼티로 이를 설정할 수 있다.

사내 프로젝트에서도 이러한 문제가 있었습니다. 프로젝트 내부에서 `builtin`으로 분류하는 그룹은 많지 않았고, 프레임워크인 vue.js가 프로젝트 전역적으로 의존도를 높게 가져가고 있기 때문에 vue를 그냥 external이 아닌 builtin으로 보자는 이야기를 나눴습니다.
|     property     | required |          type          | description                                                                                                                     |
| :--------------: | :------: | :--------------------: | ------------------------------------------------------------------------------------------------------------------------------- |
|     `pattern`    |    ☑️    |        `string`        | for specifier matching                                                                                  |
| `patternOptions` |          |        `object`        | default: `{nocomment: true}`                                                                           |
|      `group`     |    ☑️    | 사전정의된 group | to which matching imports will be positioned relatively                                      |
|    `position`    |          |  `"after" \| "before"` | Where, in relation to `group`, matching imports will be positioned; default: same position as `group` (neither before or after) |

```javascript
pathGroups: [
  {
    pattern: "vue**", 
    group: "builtin",
    position: "before",
  },
]
```
위와 같이 설정했을 때, vue로 시작하는 파일은 builtin layer로 이동한다. 또한 postion을 통해 그룹내 최상단 혹은 최하단으로 위치시킬 수 있다.

## 여기까지 적용했을 때

#### AS-IS
```javascript
import { computed, Ref, ref } from "vue";
import fs from "fs"
import { useRoute } from "vue-router";
```

#### TO-BE
```javascript
import { computed, Ref, ref } from "vue";
import { useRoute } from "vue-router";
import fs from "fs";
```

여기서 'newlines-between`옵션을 `always`로 설정한다면 그룹화 사이사이에 줄 바꿈을 적용할 수도 있다. 허나 주의할 점은 pathGroups로 group을 부여한 경우 동일 그룹에서도 줄 바꿈이 적용된다.
```javascript
// builtin(pathGroups)
import { computed, Ref, ref } from "vue";
import { useRoute } from "vue-router";
// builtin
import fs from "fs";
// external
import { isNil } from "lodash";
```

# sort-import
앞서 얘기 했듯이 eslint에는 기본적으로 [sort-import](https://eslint.org/docs/latest/rules/sort-imports#rule-details) property를 제공한다. 이 규칙을 이용해 조금 더 가독성있게 알파벳 순으로, 또 내부 구조까지 정렬 가능하다.

#### AS-IS
```javascript
import { b, a } from "util"
```
#### TO-BE
```javascript
import { a, b } from "util"
```

# husky까지 적용해보자
현재 개발환경을 좀 더 설명하자면, CI/CD가 이뤄지고 있긴 하지만 devOps측에서 만지고 있다. 작년 후반부터 bitbucket에서 gitlab으로 이관했는데, 이 때 gitlab CI/CD(github action같이 gitlab에서 제공한다.)를 사용하기로 했단다. 그런데 CI과정에서 전혀 코드 정합성을 체크하지 못하고 있고, 아예 타 부서에서 관리하고 있던 터라 관여가 어려운 상황이였다. 그래서 잘못된 코드가 그대로 자동 배포가 되버리는 사태가 나타나기도 했다.

그래서 내가 맡은 범주안에서 해결해야 했고 생각해낸 부분이 pre-commit단계에서 lint, type 등을 체크하고자 한 것이다.


> Reference
> - https://yceffort.kr/2023/05/why-esmodule


<Callout status='success'>
[링크드인](https://www.linkedin.com/in/%ED%98%84%EC%9A%B0-%EC%B5%9C-71b487282/)으로 이야기를 주고 받고 싶으시다면 언제든지 편하게 연락주세요. 🙇‍♂️
</Callout>